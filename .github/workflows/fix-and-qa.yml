name: Fix & QA RRMFT repo
on:
  workflow_dispatch: {}   # tu le lanceras à la main
permissions:
  contents: write         # autorise le workflow à pousser les correctifs

jobs:
  fix:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run one-shot fixer (inline Node)
        run: |
          node - <<'NODE'
          import fs from "node:fs";
          import path from "node:path";
          import crypto from "node:crypto";

          const root = process.cwd();
          const MANIFEST = path.join(root, "manifest.json");
          const CHECKS_OLD = path.join(root, "checksums.json");
          const META_DIR = path.join(root, "metadata");
          const CHECKS = path.join(META_DIR, "checksums.json");
          const PAIRS_ROOT = path.join(root, "pairs_table_2B");      // doublon à supprimer
          const PAIRS_EN   = path.join(root, "en", "pairs_table_2B"); // source unique

          function sha256(p){
            const buf = fs.readFileSync(p);
            return crypto.createHash("sha256").update(buf).digest("hex");
          }
          function readJSON(p){ return JSON.parse(fs.readFileSync(p, "utf-8")); }
          function writeJSON(p, o){ fs.mkdirSync(path.dirname(p), {recursive:true}); fs.writeFileSync(p, JSON.stringify(o, null, 2)); }

          if(!fs.existsSync(MANIFEST)) throw new Error("manifest.json introuvable à la racine");

          // 1) Supprimer le dossier doublon à la racine si un en/… existe
          if (fs.existsSync(PAIRS_ROOT) && fs.existsSync(PAIRS_EN)) {
            console.log("Removing duplicate pairs_table_2B at repo root…");
            fs.rmSync(PAIRS_ROOT, { recursive: true, force: true });
          }

          // 2) Déplacer checksums.json -> metadata/checksums.json (si besoin)
          if (fs.existsSync(CHECKS_OLD)) {
            fs.mkdirSync(META_DIR, { recursive: true });
            fs.renameSync(CHECKS_OLD, CHECKS);
            console.log("Moved checksums.json -> metadata/checksums.json");
          }

          // 3) Ne garder dans manifest que les chemins sous en/...
          const manifest = readJSON(MANIFEST);
          const srcs = (manifest.sources||[]).filter(s => s.path && s.path.startsWith("en/"));
          manifest.sources = srcs;

          // 4) Recalculer tous les SHA-256
          for (const s of manifest.sources) {
            const fpath = path.join(root, s.path);
            if (!fs.existsSync(fpath)) throw new Error(`Fichier manquant (manifest): ${s.path}`);
            s.sha256 = sha256(fpath);
          }
          writeJSON(MANIFEST, manifest);

          // 5) Écrire metadata/checksums.json (incluant le hash du manifest)
          const checks = {};
          for (const s of manifest.sources) checks[s.path] = s.sha256;
          checks["manifest.json"] = sha256(MANIFEST);
          writeJSON(CHECKS, checks);

          console.log("OK: manifest.json & metadata/checksums.json régénérés.");
          NODE

      - name: Commit & push changes (if any)
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if [ -n "$(git status --porcelain)" ]; then
            git add -A
            git commit -m "chore: normalize data under en/, move checksums to metadata/, rebuild manifest & checksums"
            git push
            echo "Changes pushed."
          else
            echo "No changes to commit."
          fi

  qa:
    needs: fix
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }
      - name: QA (manifest, checksums, 2A/1A/2B, critères)
        run: |
          python - <<'PY'
          import json, os, sys, hashlib, glob
          def sha256(p):
              h=hashlib.sha256()
              with open(p,'rb') as f:
                  for chunk in iter(lambda:f.read(8192), b''): h.update(chunk)
              return h.hexdigest()
          def load(p):
              with open(p,'r',encoding='utf-8') as f: return json.load(f)
          errs=[]
          man = load('manifest.json')
          checks = load('metadata/checksums.json') if os.path.exists('metadata/checksums.json') else {}

          # 1) manifest & checksums
          for s in man.get('sources', []):
              path=s['path']
              if not os.path.exists(path): errs.append(f"[MANIFEST] Fichier manquant: {path}"); continue
              d = sha256(path)
              if s.get('sha256') and s['sha256']!=d:
                  errs.append(f"[SHA] manifest.sha256 ≠ fichier ({path})")
              if checks.get(path) and checks[path]!=d:
                  errs.append(f"[SHA] checksums.json ≠ fichier ({path})")

          # 2) 2A / 1A cohérence & onFTL
          twoA = load('en/commodities_table_2A.json')['commodities']
          oneA = load('en/ftl_table_1A.json')['items']
          map2A = {(r['category'], r['commodity']): r for r in twoA}
          for it in oneA:
              k=(it['category'], it['commodity'])
              if k not in map2A: errs.append(f"[FTL] {k} présent en 1A mais absent en 2A")
              else:
                  if not map2A[k].get('onFTL', False): errs.append(f"[FTL] onFTL:false en 2A pour {k}")
                  if map2A[k]['riskScoreCommodity'] != it['riskScoreCommodity']:
                      errs.append(f"[FTL] score 1A≠2A pour {k}")

          # 3) 2B couverture & valeurs
          pairs_files = sorted(glob.glob('en/pairs_table_2B/*.json'))
          present=set()
          for pf in pairs_files:
              d=load(pf)
              cat=d['about']['category']; com=d['about']['commodity']
              present.add((cat,com))
              for p in d['pairs']:
                  for k in ['C1','C2','C3','C4','C5','C6','C7']:
                      if p[k] not in (0,1,3,9): errs.append(f"[2B] {pf}: valeur {k}={p[k]} invalide")
                  if not isinstance(p.get('riskScorePair'), int):
                      errs.append(f"[2B] {pf}: riskScorePair invalide")

          missing = sorted(set((r['category'], r['commodity']) for r in twoA) - present)
          if missing: errs.append(f"[2B] {len(missing)} denrée(s) de 2A sans fichier 2B (ex: {missing[:3]})")

          if errs:
              print("⛔ Anomalies détectées:")
              for e in errs: print(" -", e)
              sys.exit(1)
          else:
              print("✅ QA OK : manifest & checksums concordants, 1A/2A cohérents, 2B complet, critères valides.")
          PY
